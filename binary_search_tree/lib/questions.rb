# For the purposes of this challenge, we define a binary search tree to be a binary tree with the following ordering properties:
#
# The  value of every node in a node's left subtree is less than the data value of that node.
# The  value of every node in a node's right subtree is greater than the data value of that node.
# Given the root node of a binary tree, can you determine if it's also a binary search tree?
#
# Complete the function in your editor below, which has  parameter: a pointer to the root of a binary tree.
# It must return a boolean denoting whether or not the binary tree is a binary search tree. You may have to write one or more helper functions to complete this challenge.

def check_bst(root)

end


# Post Order Traversal:


# Pre Order Traversal:


# LCA:
# In a binary search tree, an *ancestor* of a `example_node` is a node
# that is on a higher level than `example_node`, and can be traced directly
# back to `example_node` without going up any levels. (I.e., this is
# intuitively what you think an ancestor should be.) Every node in a binary
# tree shares at least one ancestor -- the root. In this exercise, write a
# function that takes in a BST and two nodes, and returns the node that is the
# lowest common ancestor of the given nodes. Assume no duplicate values.
